12:30:30.437 [Test worker] INFO  o.s.b.w.e.tomcat.GracefulShutdown.shutDownGracefully - Commencing graceful shutdown. Waiting for active requests to complete
12:30:30.441 [tomcat-shutdown] INFO  o.a.coyote.http11.Http11NioProtocol.log - Pausing ProtocolHandler ["http-nio-6486"]
12:30:30.451 [tomcat-shutdown] INFO  o.s.b.w.e.tomcat.GracefulShutdown.doShutdown - Graceful shutdown complete
12:30:30.453 [Test worker] INFO  o.a.coyote.http11.Http11NioProtocol.log - Pausing ProtocolHandler ["http-nio-6486"]
12:30:30.454 [Test worker] INFO  o.a.catalina.core.StandardService.log - Stopping service [Tomcat]
12:30:30.457 [Test worker] INFO  o.a.c.c.C.[Tomcat].[localhost].[/].log - Destroying Spring FrameworkServlet 'dispatcherServlet'
12:30:30.465 [Test worker] WARN  o.a.c.loader.WebappClassLoaderBase.log - The web application [ROOT] appears to have started a thread named [lettuce-timer-3-1] but has failed to stop it. This is very likely to create a memory leak. Stack trace of thread:
 java.base@18.0.1.1/java.lang.Thread.sleep(Native Method)
 app//io.netty.util.HashedWheelTimer$Worker.waitForNextTick(HashedWheelTimer.java:600)
 app//io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:496)
 app//io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
 java.base@18.0.1.1/java.lang.Thread.run(Thread.java:833)
12:30:30.472 [Test worker] WARN  o.a.c.loader.WebappClassLoaderBase.log - The web application [ROOT] appears to have started a thread named [DefaultDispatcher-worker-1] but has failed to stop it. This is very likely to create a memory leak. Stack trace of thread:
 java.base@18.0.1.1/jdk.internal.misc.Unsafe.park(Native Method)
 java.base@18.0.1.1/java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:376)
 app//kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.park(CoroutineScheduler.kt:795)
 app//kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.tryPark(CoroutineScheduler.kt:740)
 app//kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.runWorker(CoroutineScheduler.kt:711)
 app//kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:664)
12:30:30.475 [Test worker] WARN  o.a.c.loader.WebappClassLoaderBase.log - The web application [ROOT] appears to have started a thread named [DefaultDispatcher-worker-2] but has failed to stop it. This is very likely to create a memory leak. Stack trace of thread:
 java.base@18.0.1.1/jdk.internal.misc.Unsafe.park(Native Method)
 java.base@18.0.1.1/java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:376)
 app//kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.park(CoroutineScheduler.kt:795)
 app//kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.tryPark(CoroutineScheduler.kt:740)
 app//kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.runWorker(CoroutineScheduler.kt:711)
 app//kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:664)
12:30:30.479 [Test worker] WARN  o.a.c.loader.WebappClassLoaderBase.log - The web application [ROOT] appears to have started a thread named [lettuce-nioEventLoop-5-1] but has failed to stop it. This is very likely to create a memory leak. Stack trace of thread:
 java.base@18.0.1.1/sun.nio.ch.KQueue.poll(Native Method)
 java.base@18.0.1.1/sun.nio.ch.KQueueSelectorImpl.doSelect(KQueueSelectorImpl.java:122)
 java.base@18.0.1.1/sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:129)
 java.base@18.0.1.1/sun.nio.ch.SelectorImpl.select(SelectorImpl.java:146)
 app//io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:68)
 app//io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:879)
 app//io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:526)
 app//io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
 app//io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
 app//io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
 java.base@18.0.1.1/java.lang.Thread.run(Thread.java:833)
12:30:30.481 [Test worker] WARN  o.a.c.loader.WebappClassLoaderBase.log - The web application [ROOT] appears to have started a thread named [lettuce-eventExecutorLoop-1-1] but has failed to stop it. This is very likely to create a memory leak. Stack trace of thread:
 java.base@18.0.1.1/jdk.internal.misc.Unsafe.park(Native Method)
 java.base@18.0.1.1/java.util.concurrent.locks.LockSupport.park(LockSupport.java:341)
 java.base@18.0.1.1/java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionNode.block(AbstractQueuedSynchronizer.java:506)
 java.base@18.0.1.1/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3464)
 java.base@18.0.1.1/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3435)
 java.base@18.0.1.1/java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:1623)
 java.base@18.0.1.1/java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:435)
 app//io.netty.util.concurrent.SingleThreadEventExecutor.takeTask(SingleThreadEventExecutor.java:244)
 app//io.netty.util.concurrent.DefaultEventExecutor.run(DefaultEventExecutor.java:64)
 app//io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
 app//io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
 app//io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
 java.base@18.0.1.1/java.lang.Thread.run(Thread.java:833)
12:30:30.483 [Test worker] WARN  o.a.c.loader.WebappClassLoaderBase.log - The web application [ROOT] appears to have started a thread named [lettuce-eventExecutorLoop-1-2] but has failed to stop it. This is very likely to create a memory leak. Stack trace of thread:
 java.base@18.0.1.1/jdk.internal.misc.Unsafe.park(Native Method)
 java.base@18.0.1.1/java.util.concurrent.locks.LockSupport.park(LockSupport.java:341)
 java.base@18.0.1.1/java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionNode.block(AbstractQueuedSynchronizer.java:506)
 java.base@18.0.1.1/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3464)
 java.base@18.0.1.1/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3435)
 java.base@18.0.1.1/java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:1623)
 java.base@18.0.1.1/java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:435)
 app//io.netty.util.concurrent.SingleThreadEventExecutor.takeTask(SingleThreadEventExecutor.java:244)
 app//io.netty.util.concurrent.DefaultEventExecutor.run(DefaultEventExecutor.java:64)
 app//io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
 app//io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
 app//io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
 java.base@18.0.1.1/java.lang.Thread.run(Thread.java:833)
12:30:30.485 [Test worker] WARN  o.a.c.loader.WebappClassLoaderBase.log - The web application [ROOT] appears to have started a thread named [lettuce-eventExecutorLoop-1-3] but has failed to stop it. This is very likely to create a memory leak. Stack trace of thread:
 java.base@18.0.1.1/jdk.internal.misc.Unsafe.park(Native Method)
 java.base@18.0.1.1/java.util.concurrent.locks.LockSupport.park(LockSupport.java:341)
 java.base@18.0.1.1/java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionNode.block(AbstractQueuedSynchronizer.java:506)
 java.base@18.0.1.1/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3464)
 java.base@18.0.1.1/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3435)
 java.base@18.0.1.1/java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:1623)
 java.base@18.0.1.1/java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:435)
 app//io.netty.util.concurrent.SingleThreadEventExecutor.takeTask(SingleThreadEventExecutor.java:244)
 app//io.netty.util.concurrent.DefaultEventExecutor.run(DefaultEventExecutor.java:64)
 app//io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
 app//io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
 app//io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
 java.base@18.0.1.1/java.lang.Thread.run(Thread.java:833)
12:30:30.489 [Test worker] WARN  o.a.c.loader.WebappClassLoaderBase.log - The web application [ROOT] appears to have started a thread named [lettuce-eventExecutorLoop-1-4] but has failed to stop it. This is very likely to create a memory leak. Stack trace of thread:
 java.base@18.0.1.1/jdk.internal.misc.Unsafe.park(Native Method)
 java.base@18.0.1.1/java.util.concurrent.locks.LockSupport.park(LockSupport.java:341)
 java.base@18.0.1.1/java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionNode.block(AbstractQueuedSynchronizer.java:506)
 java.base@18.0.1.1/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3464)
 java.base@18.0.1.1/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3435)
 java.base@18.0.1.1/java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:1623)
 java.base@18.0.1.1/java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:435)
 app//io.netty.util.concurrent.SingleThreadEventExecutor.takeTask(SingleThreadEventExecutor.java:244)
 app//io.netty.util.concurrent.DefaultEventExecutor.run(DefaultEventExecutor.java:64)
 app//io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
 app//io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
 app//io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
 java.base@18.0.1.1/java.lang.Thread.run(Thread.java:833)
12:30:30.492 [Test worker] WARN  o.a.c.loader.WebappClassLoaderBase.log - The web application [ROOT] appears to have started a thread named [lettuce-eventExecutorLoop-1-5] but has failed to stop it. This is very likely to create a memory leak. Stack trace of thread:
 java.base@18.0.1.1/jdk.internal.misc.Unsafe.park(Native Method)
 java.base@18.0.1.1/java.util.concurrent.locks.LockSupport.park(LockSupport.java:341)
 java.base@18.0.1.1/java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionNode.block(AbstractQueuedSynchronizer.java:506)
 java.base@18.0.1.1/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3464)
 java.base@18.0.1.1/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3435)
 java.base@18.0.1.1/java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:1623)
 java.base@18.0.1.1/java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:435)
 app//io.netty.util.concurrent.SingleThreadEventExecutor.takeTask(SingleThreadEventExecutor.java:244)
 app//io.netty.util.concurrent.DefaultEventExecutor.run(DefaultEventExecutor.java:64)
 app//io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
 app//io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
 app//io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
 java.base@18.0.1.1/java.lang.Thread.run(Thread.java:833)
12:30:30.495 [Test worker] WARN  o.a.c.loader.WebappClassLoaderBase.log - The web application [ROOT] appears to have started a thread named [lettuce-eventExecutorLoop-1-6] but has failed to stop it. This is very likely to create a memory leak. Stack trace of thread:
 java.base@18.0.1.1/jdk.internal.misc.Unsafe.park(Native Method)
 java.base@18.0.1.1/java.util.concurrent.locks.LockSupport.park(LockSupport.java:341)
 java.base@18.0.1.1/java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionNode.block(AbstractQueuedSynchronizer.java:506)
 java.base@18.0.1.1/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3464)
 java.base@18.0.1.1/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3435)
 java.base@18.0.1.1/java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:1623)
 java.base@18.0.1.1/java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:435)
 app//io.netty.util.concurrent.SingleThreadEventExecutor.takeTask(SingleThreadEventExecutor.java:244)
 app//io.netty.util.concurrent.DefaultEventExecutor.run(DefaultEventExecutor.java:64)
 app//io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
 app//io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
 app//io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
 java.base@18.0.1.1/java.lang.Thread.run(Thread.java:833)
12:30:30.497 [Test worker] WARN  o.a.c.loader.WebappClassLoaderBase.log - The web application [ROOT] appears to have started a thread named [lettuce-eventExecutorLoop-1-7] but has failed to stop it. This is very likely to create a memory leak. Stack trace of thread:
 java.base@18.0.1.1/jdk.internal.misc.Unsafe.park(Native Method)
 java.base@18.0.1.1/java.util.concurrent.locks.LockSupport.park(LockSupport.java:341)
 java.base@18.0.1.1/java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionNode.block(AbstractQueuedSynchronizer.java:506)
 java.base@18.0.1.1/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3464)
 java.base@18.0.1.1/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3435)
 java.base@18.0.1.1/java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:1623)
 java.base@18.0.1.1/java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:435)
 app//io.netty.util.concurrent.SingleThreadEventExecutor.takeTask(SingleThreadEventExecutor.java:244)
 app//io.netty.util.concurrent.DefaultEventExecutor.run(DefaultEventExecutor.java:64)
 app//io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
 app//io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
 app//io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
 java.base@18.0.1.1/java.lang.Thread.run(Thread.java:833)
12:30:30.498 [Test worker] WARN  o.a.c.loader.WebappClassLoaderBase.log - The web application [ROOT] appears to have started a thread named [lettuce-eventExecutorLoop-1-8] but has failed to stop it. This is very likely to create a memory leak. Stack trace of thread:
 java.base@18.0.1.1/jdk.internal.misc.Unsafe.park(Native Method)
 java.base@18.0.1.1/java.util.concurrent.locks.LockSupport.park(LockSupport.java:341)
 java.base@18.0.1.1/java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionNode.block(AbstractQueuedSynchronizer.java:506)
 java.base@18.0.1.1/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3464)
 java.base@18.0.1.1/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3435)
 java.base@18.0.1.1/java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:1623)
 java.base@18.0.1.1/java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:435)
 app//io.netty.util.concurrent.SingleThreadEventExecutor.takeTask(SingleThreadEventExecutor.java:244)
 app//io.netty.util.concurrent.DefaultEventExecutor.run(DefaultEventExecutor.java:64)
 app//io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
 app//io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
 app//io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
 java.base@18.0.1.1/java.lang.Thread.run(Thread.java:833)
12:30:30.500 [Test worker] INFO  o.a.coyote.http11.Http11NioProtocol.log - Stopping ProtocolHandler ["http-nio-6486"]
12:30:30.504 [Test worker] INFO  o.a.coyote.http11.Http11NioProtocol.log - Destroying ProtocolHandler ["http-nio-6486"]
12:30:30.507 [org.springframework.kafka.KafkaListenerEndpointContainer#4-0-C-1] INFO  o.s.k.l.KafkaMessageListenerContainer.info - securities-api: partitions revoked: [md.security.data.batch-0]
12:30:30.507 [org.springframework.kafka.KafkaListenerEndpointContainer#3-0-C-1] INFO  o.s.k.l.KafkaMessageListenerContainer.info - securities-api: partitions revoked: [md.security.registry-records.data-0]
12:30:30.507 [org.springframework.kafka.KafkaListenerEndpointContainer#1-0-C-1] INFO  o.s.k.l.KafkaMessageListenerContainer.info - securities-api: partitions revoked: [md.issuer.events-0]
12:30:30.508 [org.springframework.kafka.KafkaListenerEndpointContainer#5-0-C-1] INFO  o.s.k.l.KafkaMessageListenerContainer.info - securities-api: partitions revoked: [md.security.data-0]
12:30:30.507 [org.springframework.kafka.KafkaListenerEndpointContainer#2-0-C-1] INFO  o.s.k.l.KafkaMessageListenerContainer.info - securities-api: partitions revoked: [md.security.offers.data-0]
12:30:30.507 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  o.s.k.l.KafkaMessageListenerContainer.info - securities-api: partitions revoked: [md.security.assets.data-0]
12:30:30.537 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  o.s.k.l.KafkaMessageListenerContainer.info - securities-api: Consumer stopped
12:30:30.540 [org.springframework.kafka.KafkaListenerEndpointContainer#3-0-C-1] INFO  o.s.k.l.KafkaMessageListenerContainer.info - securities-api: Consumer stopped
12:30:30.543 [org.springframework.kafka.KafkaListenerEndpointContainer#5-0-C-1] INFO  o.s.k.l.KafkaMessageListenerContainer.info - securities-api: Consumer stopped
12:30:30.544 [org.springframework.kafka.KafkaListenerEndpointContainer#4-0-C-1] INFO  o.s.k.l.KafkaMessageListenerContainer.info - securities-api: Consumer stopped
12:30:30.546 [org.springframework.kafka.KafkaListenerEndpointContainer#1-0-C-1] INFO  o.s.k.l.KafkaMessageListenerContainer.info - securities-api: Consumer stopped
12:30:30.546 [org.springframework.kafka.KafkaListenerEndpointContainer#2-0-C-1] INFO  o.s.k.l.KafkaMessageListenerContainer.info - securities-api: Consumer stopped
12:30:31.024 [SpringApplicationShutdownHook] INFO  com.zaxxer.hikari.HikariDataSource.close - HikariPool-1 - Shutdown initiated...
12:30:31.025 [SpringApplicationShutdownHook] INFO  com.zaxxer.hikari.HikariDataSource.close - HikariPool-1 - Shutdown completed.
